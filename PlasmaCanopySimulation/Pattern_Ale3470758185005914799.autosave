 //this code is written for use during Burning Seed 2019, running from the 25th September to 2nd of October 2019 in Melbourne, Australia.
 //Use of the code for another event or purpose may be granted upon discussion with the author about type and purpose of the project. 
 

//todo : address color in more interesting grayscale pattern than white/black
//fix recursion to draw arbitrary n of balls
//link balls parameters to sound triggers
//affect direction of balls in more interesting way than straight line direction
 
 public class A10 extends LXPattern { 

    public String getAuthor() {
     return "Alessandro Cesana,  https://github.com/alecesana , cesaless@gmail.com ";
   }

 

     //------------- Parameters affecting grayscale pattern (currently not in use)
    public final CompoundParameter A= (CompoundParameter)
     new CompoundParameter("A",1, 1, 50) 
     .setDescription(" A");
    
        public final CompoundParameter B = (CompoundParameter)
     new CompoundParameter("B",2, 1, 70) 
     .setDescription(" B");
    
        public final CompoundParameter C = (CompoundParameter)
     new CompoundParameter("C",1, 1, 200) 
     .setDescription(" C");
    
     public final CompoundParameter D = (CompoundParameter)
     new CompoundParameter("D",1, -10, 10) 
     .setDescription("D");
    
     //----------------------------------------
    
        public final CompoundParameter s1R= (CompoundParameter)
     new CompoundParameter("s1R",1, 0, 4) 
     .setDescription(" Sphere1 radius");
    
        public final CompoundParameter s1p = (CompoundParameter)
     new CompoundParameter("s1p",1, 1, 20) 
     .setDescription(" sphere1 oscillation period(everything else oscillates with it when Olink set to true) ");
    
        public final CompoundParameter s1t = (CompoundParameter)
     new CompoundParameter("s1 thickness",1, 0.1, 4) 
     .setDescription(" sphere1 thickness");
    
     //----------------------------------------
     public final CompoundParameter s2R = (CompoundParameter)
     new CompoundParameter("s2R",2, 0.01, 4) 
     .setDescription("Sphere2 radius");
    
        public final CompoundParameter s2p = (CompoundParameter)
     new CompoundParameter("s2p",1, 1, 5) 
     .setDescription(" Sphere2 radius");
    
     public final CompoundParameter s2t = (CompoundParameter)
     new CompoundParameter("s2 thickness",0.29, 0.01, 6) 
     .setDescription(" Sphere2 radius");
    
     //----------------------------------------
    

     ///------------------------------------------------------------

    
     public final BooleanParameter OLink = (BooleanParameter)
     new BooleanParameter("OLink", true)
     .setDescription("not in use atm");
    
     public final BooleanParameter floorSwitch = (BooleanParameter)
     new BooleanParameter("floorswitch", false)
     .setDescription("not in use atm");
    
     int nBalls = 10;
     float[] cP = new float[nBalls * 3];  
     float[] cS = new float[nBalls * 3]; 


     public A10(LX lx) {
     super(lx);

     addParameter("A", this.A);
     addParameter("B", this.B);
     addParameter("C", this.C);
     addParameter("D", this.D);
    
     addParameter("OLink", this.OLink);
     addParameter("floorswitch", this.floorSwitch);
    
   
     addParameter("s1R", this.s1R);
     addParameter("s1P", this.s1p);
     addParameter("s1t", this.s1t);
    
        
     addParameter("s2R", this.s2R);
     addParameter("s2p", this.s2p);
     addParameter("s2t", this.s2t);
    

    
        // print("--------------");
        // print(cP.length);
        // print("--------------");

        //initializing things
        for(int i = 0 ;i< cP.length; i+=3){
                cP[0+i] = random(model.xMin,model.xMax);
                cP[1+i] = random(model.yMin, model.yMax);
                cP[2+i] = random(model.zMin, model.zMax);

                cS[0+i] = random(-1,1);
                cS[1+i] = random(-1,1);
                cS[2+i] = random(-1,1);
        }
   }
  //s1p,r1p to be addressed for each ball?
   public void run(double deltaMs) {

     float a = (this.A.getValuef());
     float b = (this.B.getValuef());
     float c = (this.C.getValuef());
     float d = (this.D.getValuef());
     boolean olink= (this.OLink.getValueb());
     boolean floorswitch= (this.floorSwitch.getValueb());

     //----------------------------------
     float r1 = (this.s1R.getValuef());
     float s1P = (this.s1p.getValuef());      
     float s1t = (this.s1t.getValuef());
    
     float s2P,s3P,s4P,s5P, s62;
          s2P = (this.s1p.getValuef());      

     float r2 = (this.s2R.getValuef());
     float s2t = (this.s2t.getValuef());
      

        //balls moving logic
        for(int i = 0; i< cP.length ;i+=3){

                //--------------- 
                if (cP[0+i] >= model.xMax){
                        cP[0+i]  = model.xMax;
                        cS[0+i] *= -1;
                }	
                if (cP[0+i] <= model.xMin){
                        cP[0+i]  = model.xMin;
                        cS[0+i] *= -1;
                }
                //--------------- 
                if (cP[1+i] >= model.yMax){
                        cP[1+i]  = model.yMax;
                        cS[1+i] *= -1;
                }	
                if (cP[1+i] <= model.yMin){
                        cP[1+i]  = model.yMin;
                        cS[1+i] *= -1;
                }

                //---------------- 
                if (cP[2+i] >= model.zMax){
                        cP[2+i]  = model.zMax;
                        cS[2+i] *= -1;
                }	
                if (cP[2+i] <= model.zMin){
                        cP[2+i]  = model.zMin;
                        cS[2+i] *= -1;
                }

                cP[0+i] += cS[0+i];
                cP[1+i] += cS[1+i];
                cP[2+i] += cS[2+i];

                //debugging
                // println("----------------------");
                // println("ball n"+ i/3 );
                // println(cP[0+i]);
                // println(cP[1+i]);
                // println(cP[2+i]);
                // println("----------------------");

                
        }


        for  (LXPoint p : model.getPoints()) {   
                //recursion to address all balls using for cycle doesn't work
                //for(int i =0 ;i< cP.length; i+=3){
                        int i =0;
                        if( 
                                (       
                                        (sqrt ( pow(abs( p.x  - cP[0+i]), 2) + 
                                                pow(abs( p.y  - cP[1+i]), 2) + 
                                                pow(abs( p.z  - cP[2+i]), 2))>= (s1P * r1) ) &&
                                        (sqrt ( pow(abs( p.x  - cP[0+i]), 2) + 
                                                pow(abs( p.y  - cP[1+i]), 2) + 
                                                pow(abs( p.z  - cP[2+i]), 2))<=(s1P *(r1+s1t)))        
                
                                )
                                
                                || (       
                                        (sqrt ( pow(abs( p.x  - cP[3+i]), 2) + 
                                                pow(abs( p.y  - cP[4+i]), 2) + 
                                                pow(abs( p.z  - cP[5+i]), 2))>= (s1P * r1) ) &&
                                        (sqrt ( pow(abs( p.x  - cP[3+i]), 2) + 
                                                pow(abs( p.y  - cP[4+i]), 2) + 
                                                pow(abs( p.z  - cP[5+i]), 2))<=(s1P *(r1+s1t)))        
                
                                )
                                || (       
                                        (sqrt ( pow(abs( p.x  - cP[6+i]), 2) + 
                                                pow(abs( p.y  - cP[7+i]), 2) + 
                                                pow(abs( p.z  - cP[8+i]), 2))>= (s2P * r2) ) &&
                                        (sqrt ( pow(abs( p.x  - cP[6+i]), 2) + 
                                                pow(abs( p.y  - cP[7+i]), 2) + 
                                                pow(abs( p.z  - cP[8+i]), 2))<=(s2P *(r2+s2t)))        
                
                                )
                        )

                        //todo : address color in more interesting grayscale pattern than white/black
                        {
                        setColor(p.index, #FFFFFF);
                        }
                        else {setColor(p.index,#000000);}
        // }
        }

 } //run thread closing bracket



 }
//////Leroy's jenkins, adapted to draw balls
//public class Jenkins extends BlendPattern {
//    CompoundParameter active_layers = new CompoundParameter("Density",15,0,100);
//    public Jenkins(LX lx) {
//        super(lx);
//        addParameter("Density", this.active_layers);
//        for(Integer i=0;i<100;++i){
//            layers.put(i, new ProbabilityFadeLayer(lx, Jenkins.this, i,i*333));
//        }
//        instantiate();
//    }
//    protected int numberLayersOff(){
//        return (int)Math.round(this.active_layers.getValuef());
//    }
//}
// /*
//Generates a probabilistically determined symmetrical pattern for each target
//*/
//protected class ProbabilityFadeLayer extends FadeLayer{
//    //Used for scaling the ring activation probability
//    private int activeRings;
//    int active_panels = 0;
//    private ArrayList<MEMPanel> panels;
//    private boolean render_flag = true;


//    private ProbabilityFadeLayer(LX lx, BlendPattern pattern, int layer_num, float delay){
//        super(lx,pattern,layer_num,delay);
//        this.activeRings = 0;
//        this.active_panels = 0;
//        this.panels = new ArrayList<MEMPanel>();
//    }

//    /*
//    Probabilistically generates a target set of LXPoints
//    TODO: Refine probability function and parameterise
//    */
//    protected void generateTarget(){
//        Jenkins pattern = (Jenkins)this.pattern;
//        int number_off = (int)pattern.numberLayersOff();
//        //Determine which layers to avoid rendering
//        if(this.layer_number>number_off){
//            this.render_flag = false;
//            return;
//        } else {
//            this.render_flag = true;
//        }
//        target = new ArrayList<LXPoint>();

//        for(int i=0;i<3;++i){
//            if((int)random(0,100)>(50+10*active_panels)){
//                addPanel(i);
//            }
//        }

//        for(int ring = 0;ring < 5; ++ring){
//            if((int)random(0,100)>(50+10*activeRings)){
//                addTargetRing(ring);
//            }
//        }
//        //Prevent completely dark layers
//        if(activeRings == 0){
//            generateTarget();
//            return;
//        }
//        activeRings = 0;
//        active_panels = 0;
//        this.panels = new ArrayList<MEMPanel>();
//    }
//    //Adds a symmetrical subset of a panel array to the target panel set, chance of "ring" not being added
//    private void addPanel(int ring){
//        int mod=0, rot=0;

//        switch(ring){
//            case 0: mod = (int)random(0,2); break;
//            case 1: mod = (int)random(0,4); break;
//            case 2: mod = (int)random(0,2); break;
//        }

//        if(mod==0){
//            return;
//        }

//        ArrayList<MEMPanel> temp = new ArrayList<MEMPanel>();
//        rot = (ring==1)?(int)random(1,3):0;
//        try{
//            this.panels.addAll(tcr.vivid.getSymmetricPanels(
//                ring,
//                mod,
//                rot
//            ));
//        }catch(NullPointerException e){}
//        active_panels++;
//    }

//    //Adds a symmetrical subset of a ring to the target, chance of ring not being added
//    private void addTargetRing(int ring){
//        int mod;
//        mod = (ring==0||ring==4)?(int)random(0,4):(int)random(0,7);
//        if(mod==0){
//            return;
//        }
//        if(mod==5){
//            mod=6;
//        }
//        ArrayList<LXPoint> temp = new ArrayList<LXPoint>();
//        int rot = (int)random(1,6);
//        if(this.panels != null){
//            for(MEMPanel mp : this.panels){
//                temp.addAll(mp.getSymmetricPoints(
//                    ring,
//                    mod,
//                    rot
//                ));
//            }
//        }
//        this.target.addAll(temp);
//        activeRings++;
//    }

//    protected void updateColourBuffer(LXPoint p){
//        if(!this.render_flag){
//            this.colourBuffer.put(p,#000000);
//        } else{
//            this.colourBuffer.put(
//                p,
//                LXColor.hsba(
//                    getHue(),
//                    pattern.saturation.getValuef(),
//                    fadeModulator.getValuef(),
//                    pattern.alpha.getValuef()
//                )
//            );
//        }
//    }
//}

///*
//Extend the Blend pattern and add FadeLayers to the layers hashmap. Call the instatiate() method after doing so. See Jenkins pattern for implementation example.
//*/
//protected abstract class BlendPattern extends LXPattern{
//    public HashMap<Integer, FadeLayer> layers 
//                = new HashMap<Integer, FadeLayer>();
//    public final CompoundParameter modulator_period 
//                = new CompoundParameter("modulator Period", 3000,200,10000);
//    public final CompoundParameter hue
//                = new CompoundParameter("hue", 265,0,360);
//    public final CompoundParameter hue_spread 
//                = new CompoundParameter("hue spread",90,0,360);
//    //TODO: Play with variance of saturation values across layers
//    public final CompoundParameter saturation 
//                = new CompoundParameter("saturation", 100,0,100);
//    //TODO: Play with variance of alpha values across layers
//    public final CompoundParameter alpha 
//                = new CompoundParameter("alpha", 1.0,0,1.0);

//    public BlendPattern(LX lx){
//        super(lx);
//        addParameter("modulator Period", this.modulator_period);
//        addParameter("hue", this.hue);
//        addParameter("hue spread", this.hue_spread);
//        addParameter("saturation", this.saturation);
//        addParameter("alpha", this.alpha);
//    }

//    protected void instantiate(){
//        for(FadeLayer l : layers.values()){
//            addLayer(l);
//        }
//    }

//    /*
//    Calculates the LXPoint colour from the buffers of the layers
//    return: int representing a colour value
//    */
//    protected int calcColour(LXPoint p){
//        ArrayList<Integer> layer_colours = new ArrayList<Integer>();
//        for(FadeLayer l : layers.values()){
//            int argb = l.getColour(p);
//            if(argb != 0){
//                layer_colours.add(argb);
//            }
//        }
//        switch(layer_colours.size()){
//            case 0: return 0;
//            case 1: return layer_colours.get(0);
//            default:
//        }
//        //Cumulative blend, Lightest blend option has best aesthetic
//        int accumulator = layer_colours.get(0);
//        for(int i=1;i<layer_colours.size();++i){
//            accumulator = LXColor.blend(
//                layer_colours.get(i),
//                accumulator, 
//                LXColor.Blend.LIGHTEST
//                );
//        }
//        return accumulator;
//    }

//    public void run(double deltaMs) {
//        setColors(#000000);
//        for(LXPoint p : model.points){
//            setColor(p.index,calcColour(p));
//        }
//    }
//}

///*
//When extending the fade layer, all that needs to be done is implement the generateTarget() method; i.e. update the target to be faded onto after a complete LFO oscillation in the layer. 
//*/
//protected abstract class FadeLayer extends LXLayer{
//    protected int layer_number;
//    //Pattern the layer sits in
//    protected BlendPattern pattern;
//    //The modulator driving the brightness of the layer
//    protected LXModulator fadeModulator = null;
//    //argb colour value for each LXPoint
//    protected HashMap<LXPoint, Integer> colourBuffer = new HashMap<LXPoint, Integer>();
//    //Offset the layers in time against one another
//    protected double delay;
//    protected boolean start_flag = false;
//    //The target set of LXPoints that we wish to drive onto
//    protected ArrayList<LXPoint> target = new ArrayList<LXPoint>();

//    private FadeLayer(LX lx, BlendPattern pattern, int layer_number, double delay ){
//        super(lx);
//        this.pattern        = pattern;
//        this.layer_number   = layer_number;
//        this.delay          = delay;
//        instantiate();
//    }

//    public void instantiate(){
//        generateTarget();
//        for(LXPoint p : model.points){
//            colourBuffer.put(p,0);
//        }
//    }

//    protected abstract void generateTarget();

//    /*
//    Hue is determined per layer based upon it's number with respect to the pattern's core hue value
//    */
//    protected float getHue(){
//        return (pattern.hue.getValuef()+(pattern.hue_spread.getValuef()/(getLayerNum()+1)))%360;
//    }

//    //Reimplement when extending Fadelayer if you want intra-layer colour manipulation
//    protected void updateColourBuffer(LXPoint p){
//        this.colourBuffer.put(
//            p,
//            LXColor.hsba(
//                getHue(),
//                pattern.saturation.getValuef(),
//                fadeModulator.getValuef(),
//                pattern.alpha.getValuef()/(layer_number+1)
//            )
//        );
//    }
//    protected int getColour(LXPoint p){
//        return colourBuffer.get(p);
//    }

//    public int getLayerNum(){
//        return layer_number;
//    }

//    /*
//    Called to offset the layers in time
//    TODO: Runtime modifiable LFO alteration
//    */
//    protected void startLFO(){
//        this.fadeModulator = startModulator(
//        new SinLFO(
//            0, 
//            100.0, 
//            pattern.modulator_period)
//        );
//    }

//    public List<LXPoint> getTarget(){
//        return this.target;
//    }

//    public void run(double deltams){
//        //Delay the start of the oscillator
//        if(deltams < delay){
//            this.delay-=deltams;
//            return;
//        }
//        //Start the oscillator
//        if(!this.start_flag){
//            this.start_flag = true;
//            startLFO();
//        }
//        for(LXPoint p : getTarget()){
//            updateColourBuffer(p);
//        }
//        if(fadeModulator.getValuef()<1){
//            generateTarget();
//        }
//    }
//}
 
  
